<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atherion OS Portal</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script> <!-- Socket.IO -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.18.0/dist/ort.all.js"></script> <!-- WebNN via ORT -->
    <script src="https://unpkg.com/jimp@0.22.12/browser/lib/jimp.min.js"></script> <!-- Jimp pour images -->
    <script src="https://alcdn.msauth.net/browser/2.20.0/js/msal-browser.min.js"></script> <!-- MSAL pour AAD -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> <!-- Three.js pour particles 3D -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
        :root { --neon: #00ffff; --purple: #ff00ff; --bg: linear-gradient(135deg, #0f0c29, #302b63, #24243e); }
        body { margin: 0; font-family: 'Orbitron'; background: var(--bg); color: #fff; overflow: hidden; }
        #scene-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; } /* 3D background */
        .container { position: relative; z-index: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; text-shadow: 0 0 15px var(--neon); }
        form, #dashboard { background: rgba(0,0,0,0.6); padding: 2rem; border-radius: 15px; box-shadow: 0 0 30px var(--purple); }
        input, button { padding: 0.8rem; margin: 0.5rem; border: 2px solid var(--neon); background: transparent; color: #fff; border-radius: 8px; transition: all 0.3s; }
        button:hover { box-shadow: 0 0 20px var(--neon); transform: scale(1.1); }
        video { width: 40%; border: 3px solid var(--purple); border-radius: 10px; margin: 1rem; box-shadow: 0 0 25px var(--neon); }
        .glow { animation: glow 2s infinite; } @keyframes glow { 50% { text-shadow: 0 0 25px var(--neon), 0 0 50px var(--purple); } }
    </style>
</head>
<body>
    <div id="scene-container"></div> <!-- 3D particles -->
    <div class="container">
        <div id="login">
            <h1 class="glow">Atherion OS - Futuriste Portal</h1>
            <form id="authForm">
                <input type="text" id="username" placeholder="Utilisateur" required>
                <input type="password" id="password" placeholder="Mot de passe" required>
                <button type="button" onclick="createAccount()">Créer Compte</button>
                <button type="submit">Connexion</button>
                <button type="button" onclick="loginAAD()">Connexion AAD (Edge)</button>
            </form>
            <p>Admin: yasscode / YASSINEa1!</p>
        </div>
        <div id="dashboard" style="display:none;">
            <h1 class="glow">Bienvenue dans Atherion</h1>
            <input type="text" id="roomId" placeholder="ID Salle Visio" required>
            <button onclick="joinRoom()">Rejoindre Visio (WebRTC)</button>
            <button onclick="runMLDemo()">Démo ML (WebNN - Classification Image)</button>
            <button onclick="checkIP()">Vérifier IP Protégée</button>
            <div id="videoContainer" style="display:flex;"></div>
            <div id="mlResult" class="glow"></div>
            <p>IP: <span id="ipDisplay"></span></p>
        </div>
    </div>

    <script src="imagenetClasses.js"></script> <!-- Ajoute: const IMAGENET_CLASSES = {...}; -->

    <script>
        // 3D Particles Futuristes (Three.js)
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('scene-container').appendChild(renderer.domElement);
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(1000 * 3);
        for (let i = 0; i < positions.length; i++) positions[i] = (Math.random() - 0.5) * 2000;
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 5, transparent: true });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);
        camera.position.z = 1000;
        function animate() { requestAnimationFrame(animate); particles.rotation.y += 0.001; renderer.render(scene, camera); }
        animate();

        // PWA Service Worker
        if ('serviceWorker' in navigator) navigator.serviceWorker.register('sw.js');

        // MSAL pour AAD (Edge Composer compatible)
        const msalConfig = { auth: { clientId: 'YOUR_AZURE_CLIENT_ID' } }; // Remplace !
        const msalInstance = new msal.PublicClientApplication(msalConfig);
        async function loginAAD() {
            try {
                const response = await msalInstance.loginPopup({ scopes: ['User.Read'] });
                alert('Connecté via AAD: ' + response.account.name);
                showDashboard();
            } catch (err) { alert('Erreur AAD: ' + err); }
        }

        // Web Crypto Hash
        async function hashPassword(pass) {
            const enc = new TextEncoder();
            const key = await crypto.subtle.importKey('raw', enc.encode(pass), { name: 'PBKDF2' }, false, ['deriveBits']);
            const hash = await crypto.subtle.deriveBits({ name: 'PBKDF2', salt: enc.encode('atherion'), iterations: 100000, hash: 'SHA-256' }, key, 256);
            return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Comptes (localStorage démo ; use DB en prod)
        async function createAccount() {
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            const hashed = await hashPassword(pass);
            localStorage.setItem(user, hashed);
            alert('Compte créé');
        }

        document.getElementById('authForm').addEventListener('submit', async e => {
            e.preventDefault();
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            const stored = localStorage.getItem(user);
            const hashed = await hashPassword(pass);
            const adminHash = await hashPassword('YASSINEa1!');
            if (stored && stored === hashed || (user === 'yasscode' && hashed === adminHash)) showDashboard();
            else alert('Erreur login');
        });

        function showDashboard() {
            document.getElementById('login').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';
            // Exp JS: Async iterator
            (async () => { for await (const v of async function*() { yield 1; yield 2; }()) console.log('Exp JS:', v); })();
        }

        // WebRTC avec Signaling
        const socket = io('http://localhost:3000'); // Remplace par ton server URL
        let pc, localVideo, remoteVideo;
        const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }, { urls: 'turn:turnserver.example.org', username: 'user', credential: 'pass' }] }; // TURN pour mask IP

        async function joinRoom() {
            const roomId = document.getElementById('roomId').value;
            socket.emit('join', { room: roomId, name: 'User' });

            localVideo = document.createElement('video'); localVideo.autoplay = true; localVideo.muted = true;
            remoteVideo = document.createElement('video'); remoteVideo.autoplay = true;
            document.getElementById('videoContainer').append(localVideo, remoteVideo);

            pc = new RTCPeerConnection(config);
            const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            localVideo.srcObject = stream;
            stream.getTracks().forEach(track => pc.addTrack(track, stream));

            pc.onicecandidate = e => { if (e.candidate) socket.emit('candidate', e.candidate); };
            pc.ontrack = e => remoteVideo.srcObject = e.streams[0];

            socket.on('room_users', users => createOffer()); // Pour simplifier, assume 1:1
            socket.on('getOffer', sdp => createAnswer(sdp));
            socket.on('getAnswer', sdp => pc.setRemoteDescription(sdp));
            socket.on('getCandidate', candidate => pc.addIceCandidate(candidate));
        }

        async function createOffer() {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit('offer', pc.localDescription);
        }

        async function createAnswer(sdp) {
            await pc.setRemoteDescription(sdp);
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.emit('answer', pc.localDescription);
        }

        // WebNN Démo: Classification Image (adapte pour sentiment avec texte input)
        async function runMLDemo() {
            try {
                const session = await ort.InferenceSession.create('./squeezenet1_1.onnx', { executionProviders: ['webnn'] }); // WebNN backend
                const imageTensor = await getImageTensorFromPath('./image.jpg'); // Remplace par ton image
                const feeds = { input: imageTensor };
                const results = await session.run(feeds);
                const predictions = results.output.data; // Processus pour top prediction
                const top = Array.from(predictions).map((p, i) => ({ prob: p, class: IMAGENET_CLASSES[i] })).sort((a,b) => b.prob - a.prob)[0];
                document.getElementById('mlResult').innerHTML = `Classification: ${top.class} (Prob: ${top.prob.toFixed(2)})`;
            } catch (e) { alert('Erreur WebNN: ' + e); }
        }

        async function getImageTensorFromPath(path, width=224, height=224) {
            const image = await Jimp.read(path).then(img => img.resize(width, height));
            const data = image.bitmap.data;
            const pixelCount = width * height;
            const float32Data = new Float32Array(3 * pixelCount);
            for (let i = 0; i < pixelCount; i++) {
                float32Data[pixelCount * 0 + i] = data[i * 4 + 0] / 255;
                float32Data[pixelCount * 1 + i] = data[i * 4 + 1] / 255;
                float32Data[pixelCount * 2 + i] = data[i * 4 + 2] / 255;
            }
            return new ort.Tensor('float32', float32Data, [1, 3, height, width]);
        }

        // IP Check (basique ; masqué via TURN en WebRTC)
        async function checkIP() {
            const res = await fetch('https://api.ipify.org?format=json');
            const { ip } = await res.json();
            document.getElementById('ipDisplay').textContent = ip + ' (Masqué en Visio via TURN)';
        }
    </script>
</body>
</html>