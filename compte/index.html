<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atherion OS Portal</title>
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script> <!-- Socket.IO -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.22.0/dist/ort.all.js"></script> <!-- WebNN via ORT -->
    <script src="https://unpkg.com/jimp@0.22.12/browser/lib/jimp.min.js"></script> <!-- Jimp pour images -->
    <script src="https://alcdn.msauth.net/browser/2.20.0/js/msal-browser.min.js"></script> <!-- MSAL pour AAD -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script> <!-- Three.js pour particles 3D -->
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@900&display=swap');
        :root { --neon: #00ffff; --purple: #ff00ff; --bg: linear-gradient(135deg, #0f0c29, #302b63, #24243e); --red-alert: #ff0000; }
        body { margin: 0; font-family: 'Orbitron'; background: var(--bg); color: #fff; overflow: hidden; }
        #scene-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; } /* 3D background */
        .container { position: relative; z-index: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; text-shadow: 0 0 15px var(--neon); }
        form, #dashboard { background: rgba(0,0,0,0.6); padding: 2rem; border-radius: 15px; box-shadow: 0 0 30px var(--purple); max-width: 90%; overflow-y: auto; }
        input, button, textarea, select { padding: 0.8rem; margin: 0.5rem; border: 2px solid var(--neon); background: transparent; color: #fff; border-radius: 8px; transition: all 0.3s; box-sizing: border-box; }
        button:hover { box-shadow: 0 0 20px var(--neon); transform: scale(1.1); }
        video { width: 40%; border: 3px solid var(--purple); border-radius: 10px; margin: 1rem; box-shadow: 0 0 25px var(--neon); }
        #chatMessages { height: 200px; overflow-y: scroll; background: rgba(0,0,0,0.4); padding: 1rem; border-radius: 8px; margin: 1rem 0; }
        #connectedUsers { background: rgba(0,0,0,0.4); padding: 1rem; border-radius: 8px; margin: 1rem 0; display: none; }
        #friendsList { background: rgba(0,0,0,0.4); padding: 1rem; border-radius: 8px; margin: 1rem 0; }
        #inbox { background: rgba(0,0,0,0.4); padding: 1rem; border-radius: 8px; margin: 1rem 0; }
        #inboxMessages { max-height: 300px; overflow-y: auto; }
        .message { margin: 0.5rem 0; padding: 0.5rem; border-radius: 5px; }
        .normal { background: rgba(255,255,255,0.1); }
        .important { background: rgba(255,0,0,0.3); font-weight: bold; }
        .ad { background: rgba(0,255,0,0.2); }
        .unread { border: 2px solid var(--red-alert); }
        #alertBadge { color: var(--red-alert); font-weight: bold; display: none; }
        .glow { animation: glow 2s infinite; } @keyframes glow { 50% { text-shadow: 0 0 25px var(--neon), 0 0 50px var(--purple); } }
        .user-list { list-style: none; padding: 0; }
        .user-list li { margin: 0.5rem 0; }
        #mlDemos { display: flex; flex-direction: column; align-items: center; }
        #imageUpload { margin: 1rem; }
    </style>
</head>
<body>
    <div id="scene-container"></div> <!-- 3D particles -->
    <div class="container">
        <div id="login">
            <h1 class="glow">Atherion OS - Futuriste Portal</h1>
            <form id="authForm">
                <input type="text" id="username" placeholder="Utilisateur" required>
                <input type="password" id="password" placeholder="Mot de passe" required>
                <button type="button" onclick="createAccount()">Créer Compte</button>
                <button type="submit">Connexion</button>
                <button type="button" onclick="loginAAD()">Connexion AAD (Edge)</button>
            </form>
            <p>Bienvenue sur Atherion site connectez-vous</p>
        </div>
        <div id="dashboard" style="display:none;">
            <h1 class="glow">Bienvenue dans Atherion, <span id="currentUser"></span> <span id="alertBadge"></span></h1>
            
            <!-- Inbox -->
            <div id="inboxSection">
                <h3>Boîte de Réception <span id="unreadCount"></span></h3>
                <div id="inbox"></div>
            </div>

            <!-- Amis -->
            <div id="friendsSection">
                <h3>Amis</h3>
                <input type="text" id="friendUsername" placeholder="Nom d'utilisateur ami">
                <button onclick="addFriend()">Ajouter Ami</button>
                <ul id="friendsList"></ul>
            </div>

            <!-- Visio Conférence -->
            <div id="visioSection">
                <h3>Visio Conférence</h3>
                <input type="text" id="roomName" placeholder="Nom de la salle">
                <input type="text" id="roomId" placeholder="ID Salle (optionnel)">
                <button onclick="createRoom()">Créer Salle</button>
                <button onclick="joinRoom()">Rejoindre Salle</button>
                <div id="videoContainer" style="display:flex; flex-wrap: wrap;"></div>
            </div>

            <!-- Chat -->
            <div id="chatSection">
                <h3>Chat de la Salle</h3>
                <div id="chatMessages"></div>
                <input type="text" id="chatInput" placeholder="Message...">
                <button onclick="sendMessage()">Envoyer</button>
            </div>

            <!-- Admin Section -->
            <div id="adminSection" style="display: none;">
                <h3>Gestion Admin</h3>
                <h4>Utilisateurs Connectés</h4>
                <ul id="connectedUsers"></ul>
                <h4>Tous les Comptes Créés</h4>
                <ul id="allUsersList"></ul>
                <h4>Envoyer Message</h4>
                <input type="text" id="targetUser" placeholder="Nom d'utilisateur (ou 'all' pour public)">
                <select id="messageType">
                    <option value="normal">Normal</option>
                    <option value="important-private">Important Privé</option>
                    <option value="important-public">Important Public</option>
                    <option value="ad">Pub Atherion</option>
                </select>
                <textarea id="messageText" placeholder="Message..."></textarea>
                <button onclick="sendAdminMessage()">Envoyer</button>
            </div>

            <!-- Démo ML WebNN -->
            <div id="mlSection">
                <h3>Démo ML (WebNN)</h3>
                <input type="file" id="imageUpload" accept="image/*">
                <button onclick="runMLDemo()">Classifier Image</button>
                <div id="mlResult" class="glow"></div>
            </div>

            <button onclick="checkIP()">Vérifier IP Protégée</button>
            <p>IP: <span id="ipDisplay"></span></p>
        </div>
    </div>

    <script src="imagenetClasses.js"></script> <!-- const IMAGENET_CLASSES = [...]; Assurez-vous que ce fichier existe -->

    <script>
        let currentUser = '';
        let isAdmin = false;
        let socket;
        let pc;
        let localStream;
        let remoteVideos = {};
        let friends = JSON.parse(localStorage.getItem('friends') || '[]');
        let currentRoom = '';
        let inboxMessages = []; // Local cache des messages
        let unreadImportant = 0;

        // 3D Particles Futuristes (Three.js)
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('scene-container').appendChild(renderer.domElement);
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(1000 * 3);
        for (let i = 0; i < positions.length; i++) positions[i] = (Math.random() - 0.5) * 2000;
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({ color: 0x00ffff, size: 5, transparent: true });
        const particles = new THREE.Points(geometry, material);
        scene.add(particles);
        camera.position.z = 1000;
        function animate() { 
            requestAnimationFrame(animate); 
            particles.rotation.y += 0.001; 
            renderer.render(scene, camera); 
        }
        animate();

        // PWA Service Worker
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(err => console.log('SW failed:', err));
        }

        // Connexion Socket.IO
        function initSocket() {
            socket = io('http://localhost:3000'); // Remplacez par votre URL serveur

            socket.on('connect', () => {
                console.log('Connecté au serveur');
                if (currentRoom) socket.emit('join', { room: currentRoom, name: currentUser });
                socket.emit('get_inbox', { user: currentUser }); // Récupérer inbox au connect
                if (isAdmin) socket.emit('get_all_users');
            });

            socket.on('users', (users) => {
                if (isAdmin) {
                    const ul = document.getElementById('connectedUsers');
                    ul.innerHTML = users.map(u => `<li>${u}</li>`).join('');
                    document.getElementById('adminSection').style.display = 'block';
                }
            });

            socket.on('all_users', (allUsers) => {
                if (isAdmin) {
                    const ul = document.getElementById('allUsersList');
                    ul.innerHTML = allUsers.map(u => `<li>${u} <button onclick="deleteUser('${u}')">Supprimer</button> <button onclick="accessUser('${u}')">Accéder</button></li>`).join('');
                }
            });

            socket.on('message', (msg) => {
                addMessage(msg.user, msg.text);
            });

            socket.on('inbox_update', (messages) => {
                inboxMessages = messages;
                renderInbox();
                updateNotifications();
            });

            socket.on('new_message', (msg) => {
                inboxMessages.push(msg);
                renderInbox();
                updateNotifications();
                if (msg.type.startsWith('important')) alert('Nouveau message important reçu!');
            });

            socket.on('user_joined', (user) => {
                console.log(`${user} a rejoint la salle`);
            });

            socket.on('offer', async (data) => {
                await handleOffer(data);
            });

            socket.on('answer', async (data) => {
                await pc.setRemoteDescription(new RTCSessionDescription(data));
            });

            socket.on('ice-candidate', async (data) => {
                await pc.addIceCandidate(new RTCIceCandidate(data));
            });
        }

        // MSAL pour AAD
        const msalConfig = { auth: { clientId: 'YOUR_AZURE_CLIENT_ID' } }; // Remplacez !
        const msalInstance = new msal.PublicClientApplication(msalConfig);
        async function loginAAD() {
            try {
                const response = await msalInstance.loginPopup({ scopes: ['User.Read'] });
                currentUser = response.account.name;
                alert('Connecté via AAD: ' + currentUser);
                showDashboard();
            } catch (err) { 
                alert('Erreur AAD: ' + err); 
            }
        }

        // Hash Password
        async function hashPassword(pass) {
            const enc = new TextEncoder();
            const key = await crypto.subtle.importKey('raw', enc.encode(pass), { name: 'PBKDF2' }, false, ['deriveBits']);
            const hash = await crypto.subtle.deriveBits({ 
                name: 'PBKDF2', 
                salt: enc.encode('atherion'), 
                iterations: 100000, 
                hash: 'SHA-256' 
            }, key, 256);
            return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Créer Compte (envoi au serveur)
        async function createAccount() {
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            if (!user || !pass) return alert('Champs requis');
            const hashed = await hashPassword(pass);
            socket.emit('create_account', { username: user, hashedPass: hashed });
            socket.once('account_created', (success) => {
                if (success) alert('Compte créé');
                else alert('Erreur: Utilisateur existe déjà');
            });
        }

        // Login (vérification serveur)
        document.getElementById('authForm').addEventListener('submit', async e => {
            e.preventDefault();
            const user = document.getElementById('username').value;
            const pass = document.getElementById('password').value;
            if (!user || !pass) return alert('Champs requis');
            const hashed = await hashPassword(pass);
            socket.emit('login', { username: user, hashedPass: hashed });
            socket.once('login_response', (response) => {
                if (response.success) {
                    currentUser = user;
                    isAdmin = response.isAdmin;
                    showDashboard();
                    initSocket();
                    loadFriends();
                } else {
                    alert('Erreur login');
                }
            });
        });

        function showDashboard() {
            document.getElementById('login').style.display = 'none';
            document.getElementById('dashboard').style.display = 'block';
            document.getElementById('currentUser').textContent = currentUser;
            // Exp JS: Async iterator
            (async () => { 
                for await (const v of (async function*() { yield 1; yield 2; }())) {
                    console.log('Exp JS:', v); 
                }
            })();
        }

        // Render Inbox
        function renderInbox() {
            const div = document.getElementById('inbox');
            div.innerHTML = inboxMessages.map((msg, index) => `
                <div class="message ${msg.type} ${msg.read ? '' : 'unread'}">
                    <strong>De: ${msg.from}</strong> - ${msg.text}
                    <button onclick="markAsRead(${index})">Marquer lu</button>
                </div>
            `).join('');
        }

        // Mark as Read
        function markAsRead(index) {
            inboxMessages[index].read = true;
            socket.emit('mark_read', { user: currentUser, messageId: inboxMessages[index].id });
            renderInbox();
            updateNotifications();
        }

        // Update Notifications
        function updateNotifications() {
            unreadImportant = inboxMessages.filter(msg => msg.type.startsWith('important') && !msg.read).length;
            document.getElementById('alertBadge').textContent = unreadImportant > 0 ? `Attention: ${unreadImportant} messages importants non lus!` : '';
            document.getElementById('alertBadge').style.display = unreadImportant > 0 ? 'inline' : 'none';
        }

        // Gestion Amis
        function loadFriends() {
            const ul = document.getElementById('friendsList');
            ul.innerHTML = friends.map(f => `<li>${f} <button onclick="removeFriend('${f}')">Supprimer</button></li>`).join('');
        }

        function addFriend() {
            const friend = document.getElementById('friendUsername').value;
            if (friend && !friends.includes(friend)) {
                friends.push(friend);
                localStorage.setItem('friends', JSON.stringify(friends));
                loadFriends();
                document.getElementById('friendUsername').value = '';
            }
        }

        function removeFriend(friend) {
            friends = friends.filter(f => f !== friend);
            localStorage.setItem('friends', JSON.stringify(friends));
            loadFriends();
        }

        // Admin: Send Message
        function sendAdminMessage() {
            const target = document.getElementById('targetUser').value;
            const type = document.getElementById('messageType').value;
            const text = document.getElementById('messageText').value;
            if (isAdmin && target && text) {
                socket.emit('admin_send_message', { target, type, text, from: currentUser });
                alert('Message envoyé');
            } else {
                alert('Champs requis');
            }
        }

        // Admin: Delete User
        function deleteUser(user) {
            if (isAdmin && confirm(`Supprimer ${user}?`)) {
                socket.emit('admin_delete_user', { username: user });
                socket.once('user_deleted', () => {
                    alert('Utilisateur supprimé');
                    socket.emit('get_all_users');
                });
            }
        }

        // Admin: Access User (ex. view inbox or details)
        function accessUser(user) {
            if (isAdmin) {
                socket.emit('admin_access_user', { username: user });
                socket.once('user_data', (data) => {
                    alert(`Données de ${user}: \nMessages: ${JSON.stringify(data.messages, null, 2)}`);
                });
            }
        }

        // WebRTC Config
        const config = { 
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] 
            // Ajoutez TURN si nécessaire
        };

        // Créer Salle
        async function createRoom() {
            const name = document.getElementById('roomName').value || 'Salle Anonyme';
            currentRoom = name + '_' + Date.now(); // ID unique
            document.getElementById('roomId').value = currentRoom;
            socket.emit('create', { room: currentRoom, name: currentUser });
            joinRoomInternal(currentRoom);
            alert(`Salle créée: ${currentRoom}. Partagez l'ID.`);
        }

        // Rejoindre Salle
        async function joinRoom() {
            const roomId = document.getElementById('roomId').value;
            if (!roomId) return alert('Entrez un ID de salle');
            currentRoom = roomId;
            socket.emit('join', { room: roomId, name: currentUser });
            joinRoomInternal(roomId);
        }

        async function joinRoomInternal(roomId) {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                const localVideo = document.createElement('video');
                localVideo.autoplay = true;
                localVideo.muted = true;
                localVideo.id = 'localVideo';
                document.getElementById('videoContainer').appendChild(localVideo);
                localVideo.srcObject = localStream;

                pc = new RTCPeerConnection(config);
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

                pc.onicecandidate = e => { 
                    if (e.candidate) socket.emit('ice-candidate', { candidate: e.candidate, room: roomId }); 
                };

                pc.ontrack = e => {
                    const remoteVideo = document.createElement('video');
                    remoteVideo.autoplay = true;
                    remoteVideo.id = e.track.sender.transport.id || 'remote';
                    document.getElementById('videoContainer').appendChild(remoteVideo);
                    remoteVideo.srcObject = e.streams[0];
                };

                // Créer offre si créateur
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                socket.emit('offer', { sdp: pc.localDescription, room: roomId });

            } catch (err) {
                alert('Erreur media: ' + err);
            }
        }

        async function handleOffer(data) {
            if (!pc) return;
            await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
            const answer = await pc.createAnswer();
            await pc.setLocalDescription(answer);
            socket.emit('answer', { sdp: pc.localDescription, room: data.room });
        }

        // Chat
        function sendMessage() {
            const msg = document.getElementById('chatInput').value;
            if (msg && currentRoom) {
                socket.emit('message', { text: msg, room: currentRoom, user: currentUser });
                document.getElementById('chatInput').value = '';
            }
        }

        function addMessage(user, text) {
            const div = document.getElementById('chatMessages');
            div.innerHTML += `<p><strong>${user}:</strong> ${text}</p>`;
            div.scrollTop = div.scrollHeight;
        }

        // WebNN Démo
        let session = null;
        async function initMLSession() {
            if (session) return session;
            try {
                session = await ort.InferenceSession.create('./squeezenet1_1.onnx', { executionProviders: ['webnn'] });
                console.log('WebNN chargé');
            } catch (e) {
                console.warn('WebNN échoué, fallback WebGL:', e);
                try {
                    session = await ort.InferenceSession.create('./squeezenet1_1.onnx', { executionProviders: ['webgl'] });
                    console.log('WebGL chargé');
                } catch (e2) {
                    console.warn('WebGL échoué, fallback WASM:', e2);
                    session = await ort.InferenceSession.create('./squeezenet1_1.onnx', { executionProviders: ['wasm'] });
                    console.log('WASM chargé');
                }
            }
            return session;
        }

        async function runMLDemo() {
            const fileInput = document.getElementById('imageUpload');
            if (!fileInput.files[0]) {
                alert('Sélectionnez une image');
                return;
            }

            try {
                session = await initMLSession();
                const file = fileInput.files[0];
                const imageTensor = await getImageTensorFromFile(file);
                const feeds = { input: imageTensor };
                const results = await session.run(feeds);
                const predictions = results.output.data;
                if (!IMAGENET_CLASSES) {
                    alert('IMAGENET_CLASSES non chargé. Vérifiez imagenetClasses.js');
                    return;
                }
                const top = Array.from(predictions)
                    .map((p, i) => ({ prob: p, class: IMAGENET_CLASSES[i] || `Classe ${i}` }))
                    .sort((a, b) => b.prob - a.prob)
                    .slice(0, 5);
                document.getElementById('mlResult').innerHTML = top.map(t => `<div>${t.class}: ${(t.prob * 100).toFixed(2)}%</div>`).join('');
            } catch (e) { 
                alert('Erreur WebNN/ML: ' + e.message); 
                console.error(e);
            }
        }

        async function getImageTensorFromFile(file, width=224, height=224) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    Jimp.read(URL.createObjectURL(file)).then(imgJimp => {
                        imgJimp.resize(width, height).getBuffer(Jimp.MIME_PNG, (err, buffer) => {
                            if (err) reject(err);
                            const canvas = document.createElement('canvas');
                            canvas.width = width;
                            canvas.height = height;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(img, 0, 0, width, height);
                            const imageData = ctx.getImageData(0, 0, width, height);
                            const data = imageData.data;
                            const pixelCount = width * height;
                            const float32Data = new Float32Array(3 * pixelCount);
                            for (let i = 0; i < pixelCount; i++) {
                                float32Data[i] = data[i * 4 + 0] / 255; // R
                                float32Data[pixelCount + i] = data[i * 4 + 1] / 255; // G
                                float32Data[2 * pixelCount + i] = data[i * 4 + 2] / 255; // B
                            }
                            resolve(new ort.Tensor('float32', float32Data, [1, 3, height, width]));
                        });
                    }).catch(reject);
                };
                img.src = URL.createObjectURL(file);
            });
        }

        // IP Check
        async function checkIP() {
            try {
                const res = await fetch('https://api.ipify.org?format=json');
                const { ip } = await res.json();
                document.getElementById('ipDisplay').textContent = ip + ' (Masqué en Visio via STUN/TURN)';
            } catch (e) {
                document.getElementById('ipDisplay').textContent = 'Erreur IP';
            }
        }

        // Écouteur pour chat Enter
        document.getElementById('chatInput').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // Redimensionner renderer
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
